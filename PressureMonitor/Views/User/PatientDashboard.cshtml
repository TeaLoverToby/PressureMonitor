@model Patient
@{
    ViewData["Title"] = "Patient Dashboard";
}

<div class="text-center">
    <h1 class="display-4">Patient Dashboard</h1>
    <p>Username: @Model.User.Username</p>
    
    <div class="card mt-4">
        <div class="card-header">Peak Pressure Over Selected Day</div>
        <div class="card-body">
            
            <canvas id="peakChart"></canvas>
            
            <div class="mt-3 row g-3 align-items-end">
                <div class="btn-group mb-2 justify-content-center" role="group">
                    <button type="button" class="btn btn-outline-secondary range-btn" data-hours="1">Last 1h</button>
                    <button type="button" class="btn btn-outline-secondary range-btn" data-hours="3">Last 3h</button>
                    <button type="button" class="btn btn-outline-secondary range-btn" data-hours="6">Last 6h</button>
                    <button type="button" class="btn btn-outline-secondary range-btn" data-hours="12">Last 12h</button>
                    <button type="button" class="btn btn-outline-secondary range-btn" data-hours="24">Full day</button>
                </div>
                <div class="row g-2 align-items-end">
                    <div class="col-md-2">
                        <label for="selectDay" class="form-label">Day:</label>
                        <select id="selectDay" class="form-select"></select>
                    </div>
                    <div class="col-md-2">
                        <label for="fromTime" class="form-label">From (HH:mm)</label>
                        <input type="time" id="fromTime" class="form-control"/>
                    </div>
                    <div class="col-md-2">
                        <label for="toTime" class="form-label">To (HH:mm)</label>
                        <input type="time" id="toTime" class="form-control"/>
                    </div>
                    <div class="col-md-3">
                        <button id="applyCustomRange" class="btn btn-primary" type="button">Apply Range</button>
                    </div>
                    <div class="col-md-3">
                        <button id="clearRange" class="btn btn-outline-secondary" type="button">Clear</button>
                    </div>
                </div>
            </div>
            <div id="rangeMeta" class="small text-muted mt-2"></div>
        </div>
    </div>
    
        <div class="card mt-4">
        <div class="card-header">
            <h3>Average Pressure Heat Map</h3>
        </div>
        <div class="card-body">
            <div id="heatmapContainer">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h5>Average Pressure Map</h5>
                    <div class="d-flex align-items-center gap-2">
                        <span class="small">Low (0)</span>
                        <div style="width: 200px; height: 20px; background: linear-gradient(to right, hsl(240, 100%, 50%), hsl(180, 100%, 50%), hsl(120, 100%, 50%), hsl(60, 100%, 50%), hsl(0, 100%, 50%));"></div>
                        <span class="small">High (256)</span>
                    </div>
                </div>
                <div class="text-center">
                    <canvas id="heatmapCanvas" style="border: 1px solid #ccc; max-width: 100%; height: auto;"></canvas>
                </div>
                <div class="mt-3">
                    <div class="row text-center">
                        <div class="col-md-3">
                            <strong>Min Value:</strong> <span id="minValue">-</span>
                        </div>
                        <div class="col-md-3">
                            <strong>Max Value:</strong> <span id="maxValue">-</span>
                        </div>
                        <div class="col-md-3">
                            <strong>Average:</strong> <span id="avgValue">-</span>
                        </div>
                        <div class="col-md-3">
                            <strong>Hover Value:</strong> <span id="hoverValue">-</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Graph script
        let peakChart;

        // Get the days for which there is a pressure map for the patient
        async function fetchDays() {
            const res = await fetch('/File/GetMapDays');
            if (!res.ok) return [];
            // Fetches as json array of strings so tha
            return await res.json();
        }

        // Fetch the peak data for the given day and time range selected.
        // The data received is JSON and follows format of day, rangeStart, rangeEnd and points[]
        async function fetchPeakData(day, options = {}) {
            const params = new URLSearchParams({ day });
            if (options.hoursBack) {
                params.append('hoursBack', options.hoursBack);
            }
            if (options.from && options.to) {
                params.append('from', options.from);
                params.append('to', options.to);
            }
            // Calls the backend method and follows the parameters
            const res = await fetch(`/File/getPressureGraphData?${params.toString()}`);
            if (!res.ok) return null;
            return await res.json();
        }

        /*
            Creates the line chart
            Labels - array of string labels for the X axis
            data - array of numberic values for the Y axis
         */
        function buildChart(labels, data) {
            const ctx = document.getElementById('peakChart').getContext('2d');

            // If a previous one exists, we remove it first
            if (peakChart) {
                peakChart.destroy();
            }

            // Followed documentation from the Chart.js website
            peakChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'Peak Pressure',
                        data,
                        borderColor: '#0d6efd',
                        backgroundColor: 'rgba(13,110,253,0.15)',
                        tension: 0.35, // smoooothes it
                        pointRadius: 0,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: {
                            title: { display: true, text: 'Time (by minutes)' }
                        },
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Peak Pressure' }
                        }
                    },
                    plugins: {
                        legend: { display: true }
                    }
                }
            });
        }

        // Updates the 
        function updateRangeMeta(meta) {
            const el = document.getElementById('rangeMeta');
            if (!meta || !meta.points) {
                el.textContent = '';
                return;
            }
            const start = new Date(meta.rangeStart);
            const end = new Date(meta.rangeEnd);
            el.textContent = `Showing ${meta.points.length} minute points from ` + `${start.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} to ` + `${end.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`;
        }

        // Fetches and rebuilds the chart for a given day and optional range.
        async function loadDay(day, options = {}) {
            const result = await fetchPeakData(day, options);
            if (!result || result.points.length === 0) {
                buildChart([], []);
                updateRangeMeta(null);
                return;
            }
            // Convert timestamps to display labels (HH:mm) and extract values
            const labels = result.points.map(p => new Date(p.t).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
            const values = result.points.map(p => p.v);
            buildChart(labels, values);
            updateRangeMeta(result);
            
            // Load the heat map for the selected day
            loadHeatmap(day);
        }

        // Loads all the required buttons for day/time range selection
        function updateButtons() {
            // Quick range buttons
            document.querySelectorAll('.range-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const hours = btn.getAttribute('data-hours');
                    const day = document.getElementById('selectDay').value;
                    loadDay(day, { hoursBack: hours });
                });
            });

            // Custom range (From/To) in HH:mm for the selected day
            document.getElementById('applyCustomRange').addEventListener('click', () => {
                const fromVal = document.getElementById('fromTime').value;
                const toVal = document.getElementById('toTime').value;
                const day = document.getElementById('selectDay').value;
                if (!fromVal || !toVal) return;
                loadDay(day, { from: buildDateTime(day, fromVal), to: buildDateTime(day, toVal) });
            });

            // Clear the custom range back to the full day
            document.getElementById('clearRange').addEventListener('click', () => {
                document.getElementById('fromTime').value = '';
                document.getElementById('toTime').value = '';
                const day = document.getElementById('selectDay').value;
                loadDay(day); // full day
            });
        }

        // Just a util to combine yyyy-MM-dd and HH:mm into ISO format
        function buildDateTime(dayStr, hhmm) {
            return `${dayStr}T${hhmm}:00`;
        }

        // When the page is loaded, the available days are fetched and loaded into the select box
        document.addEventListener('DOMContentLoaded', async () => {
            const select = document.getElementById('selectDay');

            const days = await fetchDays();
            if (days.length === 0) {
                select.innerHTML = '<option>No data found</option>';
                buildChart([], []);
                return;
            }

            // Adds all the available days to the option boxes
            select.innerHTML = '';
            days.forEach(d => {
                const option = document.createElement('option');
                option.value = d;
                option.textContent = d;
                select.appendChild(option);
            });

            // When the day button is clicked, we load the new day
            select.addEventListener('change', () => loadDay(select.value));

            // Reset the buttons incase there was prior data - unless we want to keep this?
            updateButtons();

            // Since this is the first time the page is being loaded, we just load the most recent day found
            loadDay(days[0]);
        });
    </script>
    
    <script>
        // Heatmap script
        const heatmapCanvas = document.getElementById('heatmapCanvas');
        const heatmapCtx = heatmapCanvas.getContext('2d');
        
        const MAX_PRESSURE_VALUE = 256;
        const GRID_SIZE = 32;
        const CELL_PIXEL_SIZE = 15; // pixels per cell
        
        heatmapCanvas.width = GRID_SIZE * CELL_PIXEL_SIZE;
        heatmapCanvas.height = GRID_SIZE * CELL_PIXEL_SIZE;
        
        // TODO: Might change the color wheel selection later - looks a bit ugly
        
        // Color mapping function - converts value (0-256) to HSL Color
        // HSL from Blue (240) to Red (0)
        function translateColor(pressure) {
            const adjusted = Math.min(pressure / MAX_PRESSURE_VALUE, 1.0);
            const hue = Math.floor(240 * (1 - adjusted));
            return `hsl(${hue}, 100%, 50%)`;
        }
        
        // Draw the heatmap
        function drawHeatmap(data) {
            // Clear prior drawing (incase there was a prior heat map)
            heatmapCtx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
            
            if (!data || data.length !== 32) {
                console.error('This data is not valid for rendering, must be a 32x32 matrix.');
                return;
            }

            // We know that the value range is 0 - 256 so we can predefine min/max
            let min = 257;
            let max = -1;
            
            let sum = 0;
            let count = 0;
            
            // Iterate through cells to find min, max, average
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const value = data[row][col];
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                    sum += value;
                    count++;
                }
            }
            
            const average = Math.round(sum / count);
            
            // Updates the display stats
            document.getElementById('minValue').textContent = min;
            document.getElementById('maxValue').textContent = max;
            document.getElementById('avgValue').textContent = average;
            
            // Draws each heat map cell
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const value = data[row][col];
                    
                    heatmapCtx.fillStyle = translateColor(value);
                    heatmapCtx.fillRect(col * CELL_PIXEL_SIZE, row * CELL_PIXEL_SIZE, CELL_PIXEL_SIZE, CELL_PIXEL_SIZE);
                }
            }
            
            // Cache the matrix data for hover logic
            heatmapCanvas.heatmapData = data;
        }
        
        // Handle mouse hover to show cell value
        heatmapCanvas.addEventListener('mousemove', (e) => {
            if (!heatmapCanvas.heatmapData) return;
            
            // We need to check if the mouse location is within the canvas
            const rect = heatmapCanvas.getBoundingClientRect();
            const scaleX = heatmapCanvas.width / rect.width;
            const scaleY = heatmapCanvas.height / rect.height;
            
            // Get mouse position relative to canvas
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // By dividing, we can find the cell indices
            const col = Math.floor(x / CELL_PIXEL_SIZE);
            const row = Math.floor(y / CELL_PIXEL_SIZE);
            
            // Ensure that the indicies are within the bounds
            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                // Check the matrix data for the pressure value
                const value = heatmapCanvas.heatmapData[row][col];
                document.getElementById('hoverValue').textContent = `${value} (Row: ${row}, Col: ${col})`;
            }
        });
        
        heatmapCanvas.addEventListener('mouseleave', () => {
            document.getElementById('hoverValue').textContent = '-';
        });
        
        // Load heatmap for the given day
        async function loadHeatmap(day) {
            try {
                const response = await fetch(`/File/getAveragePressureMap?day=${day}`);
                const result = await response.json();
                
                // Gets the matrix data of the average map
                if (result && result.averageMap) {
                    drawHeatmap(result.averageMap);
                }
            } catch (error) {
                console.error('Error loading heatmap:', error);
            }
        }
    </script>
}
